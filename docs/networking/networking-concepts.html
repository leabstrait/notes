<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Networking Concepts</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Networking Concepts</h1>
</header>
<h2 id="slides">Slides</h2>
<p><a
href="files/networking-concepts/Fundamentals+of+Networking+for+Effective+Backends-v5.pdf">Slides</a>
from <a
href="https://www.udemy.com/course/fundamentals-of-networking-for-effective-backend-design/">Hussein
Nasser’s Networking Course</a></p>
<h2 id="standard-communication-models-for-networking">Standard
communication models for Networking</h2>
<p>A standard model allows decoupling, so that the layers can be worked
on or upgraded without worrying about the rest.</p>
<h3 id="osi-open-systems-interconnect-model">OSI (Open Systems
Interconnect) Model</h3>
<p><a href="https://en.wikipedia.org/wiki/OSI_model">OSI (Open Systems
Interconnect) Model</a></p>
<p>7 Layers each describe a specific networking component</p>
<ul>
<li>Layer 7 - Application - HTTP/FTP/gRPC</li>
<li>Layer 6 - Presentation - Encoding, Serialization</li>
<li>Layer 5 - Session - Connection establishment, TLS</li>
<li>Layer 4 - Transport - UDP/TCP</li>
<li>Layer 3 - Network - IP</li>
<li>Layer 2 - Data link - Frames, Mac address Ethernet</li>
<li>Layer 1 - Physical - Electric signals, fiber or radio waves</li>
</ul>
<h3 id="the-tcpip-model-or-internet-protocol-suite">The TCP/IP Model or
Internet Protocol Suite</h3>
<p><a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">The
TCP/IP Model or Internet Protocol Suite</a></p>
<p>Much simpler than OSI, just 4 layer</p>
<ul>
<li>Application (Layer 5, 6 and 7)</li>
<li>Transport (Layer 4)</li>
<li>Internet (Layer 3)</li>
<li>Data link (Layer 2)</li>
</ul>
<p>Physical layer is not officially covered in the model</p>
<h2 id="data-link-layer">Data Link Layer</h2>
<h3 id="arp-address-resolution-protocol">ARP (Address Resolution
Protocol)</h3>
<p>It is used to translate IP addresses to MAC addresses, since IPs are
changeable and MAC addresses are (usually) fixed. ARP is local.</p>
<p><a
href="https://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump</a></p>
<ul>
<li><code>tcpdump -n -i wlp3s0 arp</code></li>
</ul>
<p><code>tcpdump</code> with src and dst filters:</p>
<ul>
<li><code>tcpdump -n -v -i wlp3s0 src 192.168.1.2 or dst 142.243.66.23</code></li>
</ul>
<p>To deliver the packet to the destination host, the source IP,
destination IP, source MAC address, and destination MAC address should
be known. Some basic rules for the packet flow:</p>
<ul>
<li>If the destination host is present in the same network, then the
packet is delivered directly to the destination host.</li>
<li>If the destination host is present in a different network, then the
packet is delivered to the default gateway first which in turn delivers
the packet to the destination host.</li>
<li>If ARP is not resolved then ARP will be resolved first.</li>
<li>MAC address never crosses its broadcast domain.</li>
</ul>
<h3 id="host-to-host-communication">Host to Host Communication</h3>
<p>Finding a device with a unique MAC address in a network is done by
sending requests to all devices in the network. Only the device with the
intended MAC address accepts the connection. But when the network is of
a bigger scale than a simple home network, this method is not possible
to scale. This is where IP addresses and routers come into play. Routers
have two different IP addresses for the two networks they are
connecting. When sending an IP packet (layer 3, router) there is a
process of AND (&amp;)ing with the subnet mask to find out if the packet
is destined to the same network or another, and passing forward until
the TTL of the packet goes to zero or the destination is found.</p>
<p><strong>TTL - Time to Live</strong> - this gives the count of how
many hops a packet can survive. <strong>TTL</strong> is decreased by 1
every hop. TTL is needed because without it the packets might hop from
router to router indefinitely.</p>
<p><em>Note [Optimization]</em> Keeping your server and database in the
same subnet will be more efficient than those two being in separate
subnets. Because the subnets are usually connected by a router (the
routers live in both networks), if the router is congested, we are gonna
see delays. Instead, we can use a switch in between the database and the
backend.</p>
<h2 id="network-layer-internet-layer">Network Layer / Internet
Layer</h2>
<p><a href="https://en.wikipedia.org/wiki/Internet_Protocol">IP</a> is
the network layer communications protocol.</p>
<p>IP Addresses are a layer 3 property. Can be set automatically or
statically, has <strong>network</strong> and <strong>host</strong>
portions. 4 bytes in IPv4 - 32 bits.</p>
<ul>
<li>a.b.c.d/x (a, b, c, d, x are integers). x is the network bits,
remaining are the host. <a
href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">CIDR
Notation</a></li>
</ul>
<h3 id="icmp-internet-control-message-protocol">ICMP (Internet Control
Message Protocol)</h3>
<p>It is used by network devices, including routers, to send error
messages and operational information indicating success or failure when
communicating with another IP address. It is used by ping and
traceroute.</p>
<ul>
<li><code>ping google.com</code></li>
<li><code>traceroute google.com</code></li>
<li><code>tcpdump -n -i wlp3s0 icmp</code></li>
</ul>
<h2 id="transport-layer">Transport Layer</h2>
<h3 id="udp-user-datagram-protocol"><a
href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP (User
Datagram Protocol)</a></h3>
<p>Layer 4 protocol, sits on top of the IP protocol (Network layer).
While IP can address a host using IP addresses, UDP has the ability to
address processes in a host using ports. Simpler and stateless protocol,
compared to TCP. Has 8-byte header on top of 20 bytes of the IP packet.
Used for:</p>
<ul>
<li>Video Streaming</li>
<li>VPN</li>
<li>DNS</li>
<li>WebRTC uses UDP. Websockets, on the other hand, use TCP</li>
<li>Games</li>
<li>P2P</li>
</ul>
<p>Multiplexing (many to one) and demultiplexing (one to many). IP
targets hosts only. Each host can have multiple applications running.
Ports can be used to identify the ‘apps’ or ‘processes’. The sender
multiplexes all inputs into single IP packets into UDP, and the receiver
demultiplexes UDP datagrams in IP packets to each app or process. A
four-tuple (Source IP, Source Port, Destination IP, Destination Port)
can represent every communication between two devices.</p>
<p><em>Note</em> Every time there is a mapping like in DNS, ARP tables,
there’s a chance of poisoning - ARP poisoning, DNS poisoning.</p>
<p><em>Note</em> Because we have 65535 ports, we can have a maximum of
65535 connections (theoretically) between a client IP and a single
server process assuming the client uses all its ports to connect to the
server process. Practically though, some of the ports are already
reserved.</p>
<p>Capturing DNS server requests and responses using
<code>tcpdump</code>:</p>
<ul>
<li><code>nslookup google.com 8.8.8.8</code></li>
<li><code>tcpdump -n -v -i wlp3s0 src 8.8.8.8 or dst 8.8.8.8</code></li>
</ul>
<pre><code>tcpdump: listening on wlp3s0, link-type EN10MB (Ethernet), snapshot length 262144 bytes

16:26:29.543518 IP (tos 0x0, ttl 64, id 17495, offset 0, flags [none], proto UDP (17), length 56)
    192.168.0.36.59200 &gt; 8.8.8.8.53: 30104+ A? google.com. (28)

16:26:29.560006 IP (tos 0x0, ttl 121, id 35261, offset 0, flags [none], proto UDP (17), length 72)
    8.8.8.8.53 &gt; 192.168.0.36.59200: 30104 1/0/0 google.com. A 172.217.169.14 (44)

16:26:29.560504 IP (tos 0x0, ttl 64, id 20170, offset 0, flags [none], proto UDP (17), length 56)
    192.168.0.36.36072 &gt; 8.8.8.8.53: 1041+ AAAA? google.com. (28)

16:26:29.590092 IP (tos 0x0, ttl 120, id 2066, offset 0, flags [none], proto UDP (17), length 84)
    8.8.8.8.53 &gt; 192.168.0.36.36072: 1041 1/0/0 google.com. AAAA 2a00:1450:4009:823::200e (56)</code></pre>
<h3 id="tcp-transmission-control-protocol"><a
href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP
(Transmission Control Protocol)</a></h3>
<p>Similar to UDP, it’s a Layer 4 protocol and can address processes in
a host using ports. It ‘controls’ the transmission, unlike UDP which is
like a firehose. Requires a connection before transmitting data.
Connection is made using a ‘handshake’. Hence it’s stateful. Has 20
bytes header. Used for reliable communications like:</p>
<ul>
<li>Remote Shell</li>
<li>Database Connections</li>
<li>Web Communications (HTTP1, HTTP2 is built on top of TCP, HTTP3 is
built on top of QUIC which is built on top of UDP and aims to be better
than TCP)</li>
<li>Any bidirectional communication</li>
</ul>
<p>TCP Connection is a Layer 5 (session) concept. The connection between
client and server must be there to send data, can’t send data outside of
a connection, requires a 3-way TCP handshake.</p>
<p>The connection is identified by four properties (Source IP, Source
Port, Destination IP, Destination Port). These four properties are
combined and hashed and saved as a file descriptor (also called
sockets).</p>
<p><em>Note</em> Socket often refers specifically to an internet socket
or TCP socket. An internet socket is minimally characterized by the
following:</p>
<ul>
<li>local socket address, consisting of the local IP address and (for
TCP and UDP, but not IP) a port number</li>
<li>protocol: A transport protocol, e.g., TCP, UDP, raw IP. This means
that (local or remote) endpoints with TCP port 53 and UDP port 53 are
distinct sockets, while IP does not have ports.</li>
<li>A socket that has been connected to another socket, e.g., during the
establishment of a TCP connection, also has a remote socket
address.</li>
</ul>
<p>The Transmission Control Protocol differs in several key features
compared to the User Datagram Protocol:</p>
<ul>
<li><strong>Ordered data transfer</strong>: the destination host
rearranges segments according to a sequence number</li>
<li><strong>Retransmission of lost packets</strong>: any cumulative
stream not acknowledged is retransmitted</li>
<li><strong>Error-free data transfer</strong>: corrupted packets are
treated as lost and are retransmitted</li>
<li><strong>Flow control</strong>: limits the rate a sender transfers
data to guarantee reliable delivery. The receiver continually hints the
sender on how much data can be received (receiver sends an
<strong>ACK</strong> with its window size [max 64KB but can be scaled up
with the window scaling factor (0-14), so that window size can go up to
1GB]). When the receiving host’s buffer fills, the next acknowledgment
suspends the transfer and allows the data in the buffer to be processed.
Employs a <strong>window sliding mechanism</strong>.</li>
<li><strong>Congestion control</strong>: the receiver might handle the
load but the middle boxes (routers) might not. lost packets (presumed
due to congestion) trigger a reduction in data delivery rate</li>
</ul>
<p>Capturing TCP segments with <code>tcpdump</code>:</p>
<ul>
<li><code>ping example.com</code></li>
<li><code>tcpdump -n -v -i wlp3s0 src 93.184.216.34 or dst 93.184.216.34 and port 80</code></li>
<li><code>curl example.com</code></li>
</ul>
<pre><code>    tcpdump: listening on wlp3s0, link-type EN10MB (Ethernet), snapshot length 262144 bytes

15:47:30.859589 IP (tos 0x0, ttl 64, id 33813, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.0.36.50584 &gt; 93.184.216.34.80: Flags [S], cksum 0x8cea (correct), seq 3227649586, win 64240, options [mss 1460,sackOK,TS val 338897101 ecr 0,nop,wscale 7], length 0

15:47:30.962271 IP (tos 0x0, ttl 51, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    93.184.216.34.80 &gt; 192.168.0.36.50584: Flags [S.], cksum 0x314f (correct), seq 2019451891, ack 3227649587, win 65535, options [mss 1460,sackOK,TS val 2278814291 ecr 338897101,nop,wscale 9], length 0

15:47:30.962345 IP (tos 0x0, ttl 64, id 33814, offset 0, flags [DF], proto TCP (6), length 52)
    192.168.0.36.50584 &gt; 93.184.216.34.80: Flags [.], cksum 0x5dc0 (correct), ack 1, win 502, options [nop,nop,TS val 338897204 ecr 2278814291], length 0

15:47:30.962544 IP (tos 0x0, ttl 64, id 33815, offset 0, flags [DF], proto TCP (6), length 126)
    192.168.0.36.50584 &gt; 93.184.216.34.80: Flags [P.], cksum 0xcfb7 (correct), seq 1:75, ack 1, win 502, options [nop,nop,TS val 338897204 ecr 2278814291], length 74: HTTP, length: 74
        GET / HTTP/1.1
        Host: example.com
        User-Agent: curl/8.2.1
        Accept: */*

15:47:31.069298 IP (tos 0x0, ttl 51, id 40104, offset 0, flags [none], proto TCP (6), length 52)
    93.184.216.34.80 &gt; 192.168.0.36.50584: Flags [.], cksum 0x5e81 (correct), ack 75, win 128, options [nop,nop,TS val 2278814398 ecr 338897204], length 0

15:47:31.070181 IP (tos 0x0, ttl 51, id 40105, offset 0, flags [none], proto TCP (6), length 1500)
    93.184.216.34.80 &gt; 192.168.0.36.50584: Flags [.], cksum 0x417a (correct), seq 1:1449, ack 75, win 128, options [nop,nop,TS val 2278814398 ecr 338897204], length 1448: HTTP, length: 1448
        HTTP/1.1 200 OK
        Age: 187681
        Cache-Control: max-age=604800
        Content-Type: text/html; charset=UTF-8
        Date: Tue, 08 Aug 2023 14:47:30 GMT
        Etag: &quot;3147526947+ident&quot;
        Expires: Tue, 15 Aug 2023 14:47:30 GMT
        Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
        Server: ECS (nyb/1DCD)
        Vary: Accept-Encoding
        X-Cache: HIT
        Content-Length: 1256

        &lt;!doctype html&gt;
        &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Example Domain&lt;/title&gt;

            &lt;meta charset=&quot;utf-8&quot; /&gt;
            &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;
            &lt;style type=&quot;text/css&quot;&gt;
            body {
                background-color: #f0f0f2;
                margin: 0;
                padding: 0;
                font-family: -apple-system, system-ui, BlinkMacSystemFont, &quot;Segoe     UI&quot;, &quot;Open Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;

            }
            div {
                width: 600px;
                margin: 5em auto;
                padding: 2em;
                background-color: #fdfdff;
                border-radius: 0.5em;
                box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02);
            }
            a:link, a:visited {
                color: #38488f;
                text-decoration: none;
            }
            @media (max-width: 700px) {
                div {
                    margin: 0 auto;
                    width: auto;
                }
            }
            &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;div&gt;
            &lt;h1&gt;Example Domain&lt;/h1&gt;
            &lt;p&gt;This domain is for use in illustrative examples in documents. You may use this
            domain in literature without prior coord [|http]

15:47:31.070244 IP (tos 0x0, ttl 64, id 33816, offset 0, flags [DF], proto TCP (6), length 52)
    192.168.0.36.50584 &gt; 93.184.216.34.80: Flags [.], cksum 0x5700 (correct), ack 1449, win 493, options [nop,nop,TS val 338897312 ecr 2278814398], length 0

15:47:31.071358 IP (tos 0x0, ttl 51, id 40106, offset 0, flags [none], proto TCP (6), length 195)
    93.184.216.34.80 &gt; 192.168.0.36.50584: Flags [P.], cksum 0x7a43 (correct), seq 1449:1592, ack 75, win 128, options [nop,nop,TS val 2278814398 ecr 338897204], length 143: HTTP

15:47:31.071371 IP (tos 0x0, ttl 64, id 33817, offset 0, flags [DF], proto TCP (6), length 52)
    192.168.0.36.50584 &gt; 93.184.216.34.80: Flags [.], cksum 0x5668 (correct), ack 1592, win 501, options [nop,nop,TS val 338897313 ecr 2278814398], length 0

15:47:31.071573 IP (tos 0x0, ttl 64, id 33818, offset 0, flags [DF], proto TCP (6), length 52)
    192.168.0.36.50584 &gt; 93.184.216.34.80: Flags [F.], cksum 0x5667 (correct), seq 75, ack 1592, win 501, options [nop,nop,TS val 338897313 ecr 2278814398], length 0

15:47:31.177303 IP (tos 0x0, ttl 51, id 40107, offset 0, flags [none], proto TCP (6), length 52)
    93.184.216.34.80 &gt; 192.168.0.36.50584: Flags [F.], cksum 0x576f (correct), seq 1592, ack 76, win 128, options [nop,nop,TS val 2278814506 ecr 338897313], length 0

15:47:31.177343 IP (tos 0x0, ttl 64, id 33819, offset 0, flags [DF], proto TCP (6), length 52)
    192.168.0.36.50584 &gt; 93.184.216.34.80: Flags [.], cksum 0x5590 (correct), ack 1593, win 501, options [nop,nop,TS val 338897419 ecr 2278814506], length 0</code></pre>
<h4 id="tcp-states">TCP States</h4>
<p>By definition TCP is a stateful protocol and it has states. Both
client and server have to maintain states like window sizes, sequences,
and the state of the connection.</p>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 8%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>State</th>
<th>Endpoint</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LISTEN</td>
<td>Server</td>
<td>Waiting for a connection request from any remote TCP end-point.</td>
</tr>
<tr class="even">
<td>SYN-SENT</td>
<td>Client</td>
<td>Waiting for a matching connection request after having sent a
connection request.</td>
</tr>
<tr class="odd">
<td>SYN-RECEIVED</td>
<td>Server</td>
<td>Waiting for a confirming connection request acknowledgment after
having both received and sent a connection request.</td>
</tr>
<tr class="even">
<td>ESTABLISHED</td>
<td>Server and client</td>
<td>An open connection, data received can be delivered to the user. The
normal state for the data transfer phase of the connection.</td>
</tr>
<tr class="odd">
<td>FIN-WAIT-1</td>
<td>Server and client</td>
<td>Waiting for a connection termination request from the remote TCP, or
an acknowledgment of the connection termination request previously
sent.</td>
</tr>
<tr class="even">
<td>FIN-WAIT-2</td>
<td>Server and client</td>
<td>Waiting for a connection termination request from the remote
TCP.</td>
</tr>
<tr class="odd">
<td>CLOSE-WAIT</td>
<td>Server and client</td>
<td>Waiting for a connection termination request from the local
user.</td>
</tr>
<tr class="even">
<td>CLOSING</td>
<td>Server and client</td>
<td>Waiting for a connection termination request acknowledgment from the
remote TCP.</td>
</tr>
<tr class="odd">
<td>LAST-ACK</td>
<td>Server and client</td>
<td>Waiting for an acknowledgment of the connection termination request
previously sent to the remote TCP (which includes an acknowledgment of
its connection termination request).</td>
</tr>
<tr class="even">
<td>TIME-WAIT</td>
<td>Server or client</td>
<td>Waiting for enough time to pass to be sure that all remaining
packets on the connection have expired.</td>
</tr>
<tr class="odd">
<td>CLOSED</td>
<td>Server and client</td>
<td>No connection state at all.</td>
</tr>
</tbody>
</table>
<p>When the server sends the last <strong>fin</strong>, the client after
receiving it sends the last <strong>ack</strong> to the server. The
server can now <strong>CLOSE</strong>. Basically there is no further
communication from the server. The client doesn’t really know if the
server received the <strong>ack</strong> or not (also called the <a
href="https://en.wikipedia.org/wiki/Two_Generals%27_Problem">Two
Generals’ Problem</a>). The client now goes into a
<strong>TIME_WAIT</strong> state, which is 4 minutes
[<code>2 MSL(Maximum Segment Length)</code>].</p>
<figure>
<img src="files/networking-concepts/tcp-socket-states.png"
alt="TCP Socket States" />
<figcaption aria-hidden="true">TCP Socket States</figcaption>
</figure>
<p><em>Note [Optimization]</em> Whoever requests the
<strong>fin</strong> will end up in the <strong>TIME_WAIT</strong>
state. We wouldn’t want the server to be flooded with these waits when
closing connections. If you own the frontend and the backend, you can
design a protocol such that you send a request so that the client can
instantiate the <strong>fin</strong> for you. The client will be in the
<strong>TIME_WAIT</strong> state, which will free up the server.</p>
<h4 id="tcp-cons">TCP Cons</h4>
<p>While TCP is a reliable protocol for connections it has some
disadvantages.</p>
<ul>
<li><p><a
href="https://en.wikipedia.org/wiki/Head-of-line_blocking">Head of Line
Blocking</a>: Head-of-line blocking in TCP occurs when a packet loss or
delay in a network causes subsequent packets to be held up, hindering
their delivery even if they’re ready to be sent.</p></li>
<li><p><a
href="https://www.youtube.com/watch?v=AAssk2N_oPk&amp;ab_channel=Computerphile">TCP
Meltdown</a>: TCP Meltdown occurs when you stack one transmission
protocol on top of another, like what happens when an OpenVPN TCP tunnel
is transporting TCP traffic inside it.</p></li>
</ul>
<h3 id="nat-network-address-translation">NAT (Network Address
Translation)</h3>
<p>IPV4 has a limit of 4 billion addresses which is not enough
considering the number of devices connected to the Internet. IPV6 also
solves this issue but for IPV4 addressing, NAT allows multiples of
devices to access the internet while also remaining private inside a
network. It gives one public IP address (the gateway) and multiple
private addresses for internal use.</p>
<p>NAT uses the IP ranges - 192.168.x.x, 10.0.0.x allocated specifically
for private networks.</p>
<p>All devices have the same public IP address which is the router. The
source port and IP address are being mapped to a different source Port
and IP for communication with the internet. This mapping called the ‘NAT
table’ lives in the router has mappings to/from public and private
ip-port pairs.</p>
<p>Applications:</p>
<ul>
<li>Private to Public translations: So we don’t run out IPv4</li>
<li>Port forwarding: Add a NAT entry in the router to forward packets to
80 to a machine (any port, maybe 8080) in your LAN. No need to have root
access to listen on port 80 on your device. Expose your local web server
publicly</li>
<li>Layer 4 Load Balancing: <a
href="https://www.haproxy.com/blog/layer-4-load-balancing-nat-mode">HAProxy
NAT Mode</a> - Your load balancer is your gateway. The gateway has an
entry from a bogus IP (e.g. 100.100.100.100) to multiple machines in the
internal network. Clients send a request to the bogus service IP. The
router intercepts that packet and replaces the service IP with a
destination server. Layer 4 reverse proxying</li>
</ul>
<h3
id="maximum-segment-size-mss-and-maximum-transmission-unit-mtu">Maximum
Segment Size (MSS) and Maximum Transmission Unit (MTU)</h3>
<p><a
href="https://www.cloudflare.com/learning/network-layer/what-is-mss/">MSS
(Maximum Segment Size)</a> acts as a limiting factor for the size of
packets or small data chunks that traverse a network. It focuses on
measuring the payload—the non-header portion—of a packet. The value of
MSS is intricately linked to another key parameter concerning packet
dimensions: <a
href="https://www.cloudflare.com/learning/network-layer/what-is-mtu/">MTU
(Maximum Transmission Unit)</a>, which includes the TCP and IP (Internet
Protocol) headers.</p>
<p>The layer 4 unit is ‘segment’. The segment slides into an ‘IP Packet’
in layer 3. The IP Packet now has the segment + headers. The IP Packet
slides into a layer 2 ‘frame’. The frame has a fixed size based on the
networking configuration. The size of the frame determines the size of
the segment. Maximum Transmission Unit (MTU) is the size of the frame.
It is a network interface property(default 1500). The larger the frame
size, the lower the latency. If you can fit more data into a single
segment you lower latency, it lowers overhead from headers and
processing. Some networks have jumbo frames up to 9000 bytes. Are there
are networks with larger MTUs?</p>
<p>Essentially, the MSS is equal to MTU minus the size of a TCP header
and an IP header:</p>
<p><span
class="math display"><em>M</em><em>T</em><em>U</em> − (<em>T</em><em>C</em><em>P</em><em>h</em><em>e</em><em>a</em><em>d</em><em>e</em><em>r</em>+<em>I</em><em>P</em><em>h</em><em>e</em><em>a</em><em>d</em><em>e</em><em>r</em>) = <em>M</em><em>S</em><em>S</em></span></p>
<figure>
<img src="files/networking-concepts/data-packet.png"
alt="A data packet" />
<figcaption aria-hidden="true">A data packet</figcaption>
</figure>
<figure>
<img src="files/networking-concepts/data-frame.png" alt="Data Frame" />
<figcaption aria-hidden="true">Data Frame</figcaption>
</figure>
<p>One of the key differences between MTU and MSS is that if a packet
exceeds a device’s MTU, it is broken up into smaller pieces, or
“fragmented.” These frames then have to be assembled and then the frame
itself has to have ‘More Fragments (MF)’ bit set in it’s flags. In
contrast, if a packet exceeds the MSS, it is dropped and not
delivered.</p>
<p>The maximum MTU of the internet is 1500 bytes, and the maximum MSS is
1460 bytes.</p>
<blockquote>
<p>Since then various other transmission systems have come and gone, but
the lowest MTU value of them has still been Ethernet at 1500 bytes.
Going bigger than the lowest MTU on a network will either result in IP
fragmentation, or the need to do path MTU detection. Both of which have
their own sets of problems. Even if sometimes large OS vendors dropped
the default MTU to even lower at times.</p>
</blockquote>
<p>Check MTU in a linux machine</p>
<ul>
<li><code>ip a | grep -i mtu</code></li>
</ul>
<p><strong>Path MTU Discovery (PMTUD)</strong></p>
<p>MTU is a network interface property; each host can have a different
value. You really need to use the smallest MTU in the network. Path MTU
helps determine the MTU on the network path. The client sends an IP
packet with its MTU(in the options field of the IP header) and a DF
flag. The host with a smaller MTU will need to fragment but can’t. The
host sends back an ICMP message indicating fragmentation is needed(Type
3 – Destination Unreachable: Code 4 Fragmentation required, and DF flag
set), which will lower the MTU. Path MTU can discover the network’s
lowest MTU with ICMP.</p>
<figure>
<img src="files/networking-concepts/image.png"
alt="Path MTU Discovery" />
<figcaption aria-hidden="true">Path MTU Discovery</figcaption>
</figure>
<h2 id="application-layer">Application Layer</h2>
<h2 id="popular-networking-protocols">Popular Networking Protocols</h2>
<h3 id="domain-name-system-dns">Domain Name System (DNS)</h3>
<p>IP addresses are essential for transmitting IP packets, forming the
foundation of network communications, while DNS serves the purpose of
converting hostnames (text) into IP addresses (numbers). Hostnames can
remain unchanged even if IP addresses change, and a single service can
have multiple IP addresses. DNS facilitates the selection of the most
suitable IP address(es) based on factors like geographic proximity and
lower server loads, ensuring optimal performance. DNS is built on top of
UDP.</p>
<p>Beyond IP addresses, DNS contains various types of information:</p>
<ul>
<li>A Record (Address Record): Associates hostnames with IPv4
addresses.</li>
<li>AAAA Record: Links hostnames to IPv6 addresses.</li>
<li>CNAME Record (Canonical Name Record): Establishes aliases for
hostnames, often utilized for subdomains.</li>
<li>MX Record (Mail Exchanger Record): Specifies mail servers for
receiving domain email.</li>
<li>NS Record (Name Server Record): Identifies authoritative name
servers for a domain.</li>
<li>TXT Record (Text Record): Stores diverse text-based data for
different uses.</li>
</ul>
<p>These are some of the more well-known records. <a
href="https://www.cloudflare.com/en-gb/learning/dns/dns-records/">Learn
more</a></p>
<p>All DNS records incorporate a ‘TTL’ (Time-to-Live), indicating how
often a DNS server refreshes that record.</p>
<p>The DNS resolution process involves multiple steps:</p>
<ol type="1">
<li><strong>Local Caching</strong>: The device checks its cache for the
requested domain’s IP address.</li>
<li><strong>Recursive Query</strong>: If not cached, the device asks a
DNS resolver (ISP or public service).</li>
<li><strong>Iterative Queries</strong>: The resolver seeks root and TLD
servers for info about the domain.</li>
<li><strong>Authoritative Query</strong>: The resolver queries the
domain’s authoritative name server.</li>
<li><strong>Response to Resolver</strong>: Authoritative server responds
with the IP address.</li>
<li><strong>Resolver Response</strong>: Resolver sends the IP to the
client.</li>
<li><strong>Client Access</strong>: Client connects to the web server
and requests content.</li>
<li><strong>Optional Caching</strong>: Resolver may cache the IP for
future use.</li>
</ol>
<p>The DNS structure comprises distinct layers—DNS recursor, Root
nameserver, TLD nameserver, and Authoritative nameserver—intentionally
designed for distribution, except for the centralized Authoritative
nameserver. This design is crucial due to DNS being the most queried
system.</p>
<p>However, DNS lacks inherent encryption, enabling ISPs to view all DNS
traffic. This unencrypted exposure elevates the risk of potential
vulnerabilities, including DNS hijacking, redirecting users to malicious
sites, and DNS poisoning, inserting false data into DNS queries. As a
result, attackers can exploit these openings. To address these security
risks, DNS over TLS (DoT) and DNS over HTTPS (DoH) protocols aim to
introduce encryption.</p>
<p>DNS querying using <code>nslookup</code></p>
<ul>
<li><code>nslookup labinojha.com.np</code></li>
<li><code>nslookup labinojha.com.np 8.8.8.8   # non-authoritative</code></li>
<li><code>nslookup -type=A labinojha.com.np</code></li>
<li><code>nslookup -type=txt labinojha.com.np</code></li>
<li><code>nslookup -type=ns labinojha.com.np</code></li>
<li><code>nslookup labinojha.com.np may.ns.cloudflare.com  # authoritative name server</code></li>
</ul>
<p><code>dig</code> is another tool that can be used.</p>
<h3 id="transport-layer-security-tls">Transport Layer Security
(TLS)</h3>
<p>Fundamental encryption for network communication. Primarily used for
securing HTTP, extends to email, messaging, VoIP.</p>
<p>Derived from SSL, initially SSL 3.1. “TLS” and “SSL” terms used
interchangeably due to history.</p>
<p><strong>HTTP (Hypertext Transfer Protocol):</strong></p>
<ul>
<li><p>Unencrypted protocol for data transmission over the web.</p></li>
<li><p>Data sent in plain text, susceptible to interception and
eavesdropping.</p>
<figure>
<img src="files/networking-concepts/http-tcp-handshake.png"
alt="HTTP TCP Handshake" />
<figcaption aria-hidden="true">HTTP TCP Handshake</figcaption>
</figure></li>
</ul>
<p><strong>HTTPS (Hypertext Transfer Protocol Secure):</strong></p>
<ul>
<li><p>Secured version of HTTP.</p></li>
<li><p>Uses encryption to safeguard data during transmission.</p></li>
<li><p>Employs a handshake process to set up secure communication.</p>
<figure>
<img src="files/networking-concepts/https-tcp-handshake.png"
alt="HTTPS TCP Handshake" />
<figcaption aria-hidden="true">HTTPS TCP Handshake</figcaption>
</figure></li>
</ul>
<p><strong>Handshake and Key Exchange:</strong></p>
<ul>
<li>During the handshake, the client and server agree on a symmetric
encryption key for data encryption.</li>
<li>This key is used for both encryption and decryption.</li>
<li>The process uses asymmetric encryption for securely exchanging this
symmetric key.</li>
</ul>
<p><strong>Asymmetric Encryption:</strong></p>
<ul>
<li>Involves a public-private key pair.</li>
<li>Public key encrypts data, private key decrypts it.</li>
<li>Used for secure exchange of the symmetric encryption key during the
handshake.</li>
</ul>
<p><strong>Symmetric Encryption:</strong></p>
<ul>
<li>Same key for both encryption and decryption. SImple XORing the data
with the key can be used to encrypt and decrypt the data.</li>
<li>Efficient for bulk data encryption.</li>
<li>Challenge lies in secure key exchange.</li>
</ul>
<p><strong>Certificate and Authentication:</strong></p>
<ul>
<li>Server provides a digital certificate with its public key.</li>
<li>Certificate issued by a trusted Certificate Authority (CA). The
certificate actually contains the public key of the server.</li>
<li>Allows the client to verify the server’s identity.</li>
</ul>
<p>Modern cryptographic algorithms like AES are used for symmetric
encryption in HTTPS, not XOR. - Asymmetric encryption is used mainly for
key exchange, not for encrypting the actual data due to its speed
overhead.</p>
<p><strong>TLS 1.2</strong></p>
<figure>
<img src="files/networking-concepts/tls-1_2.png" alt="TLS 1.2" />
<figcaption aria-hidden="true">TLS 1.2</figcaption>
</figure>
<p>TLS 1.2 relies on the RSA asymmetric encryption algorithm. Here’s the
handshake process in this version:</p>
<p>This uses RSA which is a popular asymmetric encrytion algorithm.</p>
<ol type="1">
<li>The client send a hello.</li>
<li>The server sends its public key which is the certificte.</li>
<li>Theclient send the symmetric key, encrypted with the the servers
public key</li>
<li>The server decrypts with it’s private key to get the symmetric key.
Now both server and client have the symmetric key which they can use to
encrypt and decrypt their communication.</li>
</ol>
<p>The TLS 1.2 handshake involves two round trips. However, a challenge
with this approach is the absence of perfect <a
href="https://en.wikipedia.org/wiki/Forward_secrecy">forward
secrecy</a>. If a private key is compromised in the future, an attacker
could potentially decrypt past sessions. This is why security
certificates are periodically renewed.</p>
<p><strong>Diffie-Hellman Key Exchange</strong> Diffie-Hellman key
exchange is used instead of RSA for achieving forward secrecy. This
involves two private keys and one public key to generate a shared
symmetric key.</p>
<p><img src="files/networking-concepts/diffie-hellman-1.png"
alt="Diffie Hellman" /> <img
src="files/networking-concepts/diffie-hellman-2.png"
alt="Diffie Hellman" /></p>
<p><strong>TLS 1.3</strong> <img
src="files/networking-concepts/tls-1_3.png" alt="TLS 1.3" /></p>
<p>In TLS 1.3, the process is enhanced. Here’s the updated handshake
process:</p>
<ol type="1">
<li>The client generates and combines a public-private key pair. It
transmits both the public-private pair and the public key to the
server.</li>
<li>The server generates its own private key, combines it with the
client’s public key, and sends this pair to the client. Using these
keys, the server can generate a symmetric key.</li>
<li>The client, equipped with the keys from the server and its own pair,
generates a symmetric key. This shared symmetric key enables secure
communication between the client and the server.</li>
</ol>
<p>TLS 1.3 introduces several improvements, including the potential for
a one-round-trip or even a zero-round-trip handshake, enhancing
efficiency while maintaining strong security.</p>
</body>
</html>
